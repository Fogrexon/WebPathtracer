# ModelBVH型 how to use

## simpleIntersect.hppで定義されているもの

### point3型
long doubleの変数x,y,zから成り、3次元空間上の座標を表す

### vec3型
long doubleの変数x,y,zから成り、3次元空間上のベクトルを表す
機能としてはpoint3と全く一緒だが役割を明示するために別の型として定義

### tri3型
point3型の変数３つから成り、3次元空間上の三角形を表す

### determinant
vec3型の変数を3つ与えるとそれらを与えた順に並べて作った3次元平方行列の行列式を求める
サラスの方法を用いている

### crossProduct
vec3型の変数を2つ与えるとそれらの与えた順のクロス積(外積)を求める

### normalize
vec3型の変数を与えると、偏角を保ちつつ絶対値が1になるように定数倍する
零が与えられた場合零を返す

### normalVector
tri型の変数を与えると、その三角形の法線ベクトルを返す

### intersectTriangle
point3型の変数 Oとvec3型の変数 dとtri3型の変数 Tを与えるとOを起点とした向きがdの光線がTと交差するかどうかを判定し、交差する場合はその座標も返す

### intersectBox
point3 Oとvec3 dとpoint3 P,Qを与えるとOを起点とした向きがdの光線が点P,Qを対角線上にもつ直方体と交差するかどうかを判定し、交差する場合はその座標も返す

## BVH.hppで定義されているもの

### rayHit型
後述のintersectModelの返り値に使われる
光線とモデルの当たり判定の結果として返す情報を格納する

### ModelBVHクラス
モデルを以下の方法で与えるとそのモデルにBVHを与え、モデルと光線の当たり判定を高速に行うようになる

#### コンストラクタ
クラスのコンストラクタはpoint3型のstd::vectorとstd::array<int,3>のstd::vectorを要求する
前者はモデルの頂点のリストであり、後者はモデルのポリゴン**のインデックス**のリスト

#### intersectModel
point3 Oとvec3 dを与えるとOを起点とした向きがdの光線がモデルと交差するかどうかを高速に判定し、交差する場合はその座標も返す

### 使用例

```=cpp
#include <iostream>
#include "BVH.hpp"

int main(void){

    std::vector<point3> vertex(10);
    vertex = {
        {0,0,5},
        {-2,-2,2},
        {2,-2,2},
        {-2,2,2},
        {2,2,2},
        {-2,-2,-2},
        {2,-2,-2},
        {-2,2,-2},
        {2,2,-2},
        {0,0,-5},
    };

    std::vector<std::array<int,3>> polygon = {
        {0,1,2},
        {0,1,3},
        {0,3,4},
        {0,2,4},
        {1,2,4},
        {1,3,4},

        {1,2,5},
        {6,2,5},
        {1,3,5},
        {7,3,5},
        {2,4,6},
        {8,4,6},
        {3,4,7},
        {8,4,7},

        {5,6,8},
        {5,7,8},
        {5,6,9},
        {5,7,9},
        {6,8,9},
        {7,8,9},
    };

    ModelBVH bvh(vertex,polygon);
    
    point3 C = {0,-10,0};
    vec3 d = {0,1,0};

    for(int j=-15;j<=15;j++){
        for(int i=-15;i<=15;i++){
            point3 O = C;
            O.x += (double)(i)/2.0;
            O.z += (double)(j)/2.0;

            rayHit t = bvh.intersectModel(O,d);
            if(t.isHit){
                if(t.index<=9){
                    std::cout << t.index;
                }else if(t.index<=36){
                    std::cout << (char)('A'+t.index-10);
                }else if(t.index<=62){
                    std::cout << (char)('a'+t.index-36);
                }else{
                    std::cout << '#';
                }
            }else{
                std::cout << '.';
            }
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

### 出力
```
...............................
...............................
...............................
...............................
...............................
...............B...............
...............B...............
..............BBB..............
.............BBBBB.............
.............BBBBB.............
............BBBBBBB............
...........BBBBBBBBB...........
...........RHHHHHHHH...........
...........RRHHHHHHH...........
...........RRRHHHHHH...........
...........RRRRHHHHH...........
...........RRRRRHHHH...........
...........RRRRRRHHH...........
...........RRRRRRRHH...........
...........RRRRRRRRH...........
............ZZZZZZZ............
.............ZZZZZ.............
.............ZZZZZ.............
..............ZZZ..............
...............Z...............
...............Z...............
...............................
...............................
...............................
...............................
...............................
```
